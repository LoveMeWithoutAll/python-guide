# 
msgid ""
msgstr ""
"Project-Id-Version: pythonguide 0.0.1\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2014-11-30 22:28\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ..\..\scenarios\speed.rst:2
msgid "Speed"
msgstr ""

#: ..\..\scenarios\speed.rst:4
msgid ""
"CPython, the most commonly used implementation of Python, is slow for CPU "
"bound tasks. `PyPy`_ is fast."
msgstr ""

#: ..\..\scenarios\speed.rst:7
msgid ""
"Using a slightly modified version of `David Beazleys`_ CPU bound test code "
"(added loop for multiple tests), you can see the difference between CPython "
"and PyPy's processing."
msgstr ""

#: ..\..\scenarios\speed.rst:37
msgid "Context"
msgstr ""

#: ..\..\scenarios\speed.rst:41 ..\..\scenarios\speed.rst:59
msgid "The GIL"
msgstr ""

#: ..\..\scenarios\speed.rst:43
msgid ""
"`The GIL`_ (Global Interpreter Lock) is how Python allows multiple threads "
"to operate at the same time. Python's memory management isn't entirely "
"thread-safe, so the GIL is required to prevent multiple threads from running"
" the same Python code at once."
msgstr ""

#: ..\..\scenarios\speed.rst:48
msgid ""
"David Beazley has a great `guide`_ on how the GIL operates. He also covers "
"the `new GIL`_ in Python 3.2. His results show that maximizing performance "
"in a Python application requires a strong understanding of the GIL, how it "
"affects your specific application, how many cores you have, and where your "
"application bottlenecks are."
msgstr ""

#: ..\..\scenarios\speed.rst:55 ..\..\scenarios\speed.rst:65
msgid "C Extensions"
msgstr ""

#: ..\..\scenarios\speed.rst:61
msgid ""
"`Special care`_ must be taken when writing C extensions to make sure you "
"register your threads with the interpreter."
msgstr ""

#: ..\..\scenarios\speed.rst:69
msgid "Cython"
msgstr ""

#: ..\..\scenarios\speed.rst:71
msgid ""
"`Cython <http://cython.org/>`_ implements a superset of the Python language "
"with which you are able to write C and C++ modules for Python. Cython also "
"allows you to call functions from compiled C libraries. Using Cython allows "
"you to take advantage of Python's strong typing of variables and operations."
msgstr ""

#: ..\..\scenarios\speed.rst:76
msgid "Here's an example of strong typing with Cython:"
msgstr ""

#: ..\..\scenarios\speed.rst:103
msgid ""
"This implementation of an algorithm to find prime numbers has some "
"additional keywords compared to the next one, which is implemented in pure "
"Python:"
msgstr ""

#: ..\..\scenarios\speed.rst:128
msgid ""
"Notice that in the Cython version you declare integers and integer arrays to"
" be compiled into C types while also creating a Python list:"
msgstr ""

#: ..\..\scenarios\speed.rst:151
msgid ""
"What is the difference? In the upper Cython version you can see the "
"declaration of the variable types and the integer array in a similar way as "
"in standard C. For example `cdef int n,k,i` in line 3. This additional type "
"declaration (i.e. integer) allows the Cython compiler to generate more "
"efficient C code from the second version. While standard Python code is "
"saved in :file:`*.py` files, Cython code is saved in :file:`*.pyx` files."
msgstr ""

#: ..\..\scenarios\speed.rst:158
msgid "What's the difference in speed? Let's try it!"
msgstr ""

#: ..\..\scenarios\speed.rst:184
msgid "These lines both need a remark:"
msgstr ""

#: ..\..\scenarios\speed.rst:192
msgid ""
"The `pyximport` module allows you to import :file:`*.pyx` files (e.g., "
":file:`primesCy.pyx`) with the Cython-compiled version of the `primes` "
"function. The `pyximport.install()` command allows the Python interpreter to"
" start the Cython compiler directly to generate C-code, which is "
"automatically compiled to a :file:`*.so` C-library. Cython is then able to "
"import this library for you in your Python code, easily and efficiently. "
"With the `time.time()` function you are able to compare the time between "
"these 2 different calls to find 500 prime numbers. On a standard notebook "
"(dual core AMD E-450 1.6 GHz), the measured values are:"
msgstr ""

#: ..\..\scenarios\speed.rst:209
msgid ""
"And here the output of an embedded `ARM beaglebone "
"<http://beagleboard.org/Products/BeagleBone>`_ machine:"
msgstr ""

#: ..\..\scenarios\speed.rst:219
msgid "Pyrex"
msgstr ""

#: ..\..\scenarios\speed.rst:223
msgid "Shedskin?"
msgstr ""

#: ..\..\scenarios\speed.rst:226
msgid "Numba"
msgstr ""

#: ..\..\scenarios\speed.rst:227
msgid "Write about Numba and the autojit compiler for NumPy"
msgstr ""

#: ..\..\scenarios\speed.rst:230 ..\..\scenarios\speed.rst:234
msgid "Threading"
msgstr ""

#: ..\..\scenarios\speed.rst:238
msgid "Spawning Processes"
msgstr ""

#: ..\..\scenarios\speed.rst:242
msgid "Multiprocessing"
msgstr ""

#: ..\..\scenarios\speed.rst:0
msgid "Todo"
msgstr ""
